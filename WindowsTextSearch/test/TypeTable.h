#pragma once
/////////////////////////////////////////////////////////////////////
// TypeTable.h - Holds types defined/used for a set of files       //
// Ver 1.0                                                         //
// Application: Project #2 - Dependency Analysis - CSE-687         //
// Platform:    Dell Inspiron 5520, Win 10, Visual Studio 2015     //
// Author:      Ammar Salman, EECS, Syracuse University            //
//              (313) 788-4694  hoplite.90@hotmail.com             //
/////////////////////////////////////////////////////////////////////
/*
* Package Operations:
* -------------------
* This package processes AST generated by CodeAnalyzer to extract all
* defined types within a set of files and records the information.
* It also uses the FileMap from CodeAnalyzer to tokenize the processed
* files in order to extract all the used types as well. 
*
* Public Interface:
* TypeValue tv;
* string name = tv.Name();
* string pName = tv.ParentNamespace();
* string type = tv.Type();
* vector<string> qualifiedName = tv.QualifiedName();
* TypeValue tv2;
* bool isEqual = tv2.qNameEquals(qualifiedName);
* bool typeValuesEqual = tv == tv2;
*
*	TypeTable typeTable;
* typeTable.ExtractDefinedTypes(argc, argv);
* typeTable.ExtractUsedTypes();
* typeTable.Print();
* auto defined = typeTable.definedTypes();
* auto used = typeTable.usedTypes();
* auto included = typeTable.UsedLibraries();
*
*
* Required Files:
* ---------------
*   - TypeTable.h, TypeTable.cpp, ActionsAndRules.h, AbstrSynTree.h, Executive.h
*
* Build Process:
* --------------
*   devenv DependencyAnalysis.sln /debug rebuild
*
* Maintenance History:
* --------------------
* Ver 1.0 : 5 March 2017
* - first release
*
*/

#include <vector>
#include <unordered_map>
#include <string>
#include <set>

#include "..\CodeAnalyzer\Parser\ActionsAndRules.h"
#include "..\CodeAnalyzer\AbstractSyntaxTree\AbstrSynTree.h"
#include "..\CodeAnalyzer\Analyzer\Executive.h"

using namespace std;
using namespace CodeAnalysis;

namespace DependencyAnalysis {
	

	// --------------------------------------------------------------------------------------
	// -----< TypeValue class area >---------------------------------------------------------
	// --------------------------------------------------------------------------------------

	// specifies node for each defined type found in the processes file
	class TypeValue {
		string name;
		string pNamespace;
		string type;
		vector<string> qualifiedName;
		friend class TypeTable;
	public:
		const string& Name() const { return name; }
		const string& ParentNamespace() const { return pNamespace; }
		const string& Type() const { return type; }
		const vector<string>& QualifiedName() const { return qualifiedName; }
		bool qNameEquals(vector<string>& qName);
		bool operator==(TypeValue& tv);
	};

	// -----< Compare Qualified Names function >--------------------------------------------
	/* takes qualified name from other function and returns if they are equal or not*/
	inline bool TypeValue::qNameEquals(vector<string>& qName) {
			if (qualifiedName.size() != qName.size()) return false;
			for (size_t i = 0; i < qualifiedName.size(); ++i)
				if (qualifiedName[i] != qName[i]) return false;
			return true;
	}

	// -----< Compare two TypeValues function >---------------------------------------------
	/* takes another TypeValue and checks if everything is the same or not */
	inline bool TypeValue::operator==(TypeValue& tv) {
		if (tv.name != name) return false;
		if (tv.pNamespace != pNamespace) return false;
		if (tv.type != type) return false;
		if (!tv.qNameEquals(qualifiedName)) return false;
		return true;
	}


	// --------------------------------------------------------------------------------------
	// -----< TypeTable class area >---------------------------------------------------------
	// --------------------------------------------------------------------------------------


	// holds information about defined/used types within a file
	class TypeTable {
	public:
		TypeTable();
		TypeTable(const TypeTable& tt);
		~TypeTable();
		void ExtractDefinedTypes(int argc, char** argv);
		void ExtractUsedTypes();
		void Print();
		const unordered_map <string, vector<TypeValue>>& definedTypes() const { return DefinedTypes; }
		const unordered_map <string, set<string>> usedTypes() const { return UsedTypes; }
		const unordered_map <string, vector<string>> UsedLibraries() const { return IncludedLibraries; }

	private:
		vector<string> FileList;
		vector<string> qName;
		set<string> mapKeys;
		
		unordered_map<string, vector<string>> IncludedLibraries;
		unordered_map<string, vector<TypeValue>> DefinedTypes;
		unordered_map<string, set<string>> UsedTypes;

		Repository* CodeRepository;
		ASTNode* GlobalScopeNode;

		void UpdateFileList(const CodeAnalysisExecutive::FileMap& fileMap);

		void DoAction(ASTNode* node);
		void ManageContainer(ASTNode* node);
		void ManageFunction_Enum(ASTNode* node);
		void ManageDeclaration(DeclarationNode& node);
		void ManageStatements(vector<pair<Scanner::ITokCollection*, string>>& statements);

		bool isValidToken(string& tok);
	};

}
